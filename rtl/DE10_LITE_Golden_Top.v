// ============================================================================
//   Ver  :| Author					:| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du			:| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`define ENABLE_ADC_CLOCK
`define ENABLE_CLOCK1
`define ENABLE_CLOCK2
`define ENABLE_SDRAM
`define ENABLE_HEX0
`define ENABLE_HEX1
`define ENABLE_HEX2
`define ENABLE_HEX3
`define ENABLE_HEX4
`define ENABLE_HEX5
`define ENABLE_KEY
`define ENABLE_LED
`define ENABLE_SW
`define ENABLE_VGA
`define ENABLE_ACCELEROMETER
`define ENABLE_ARDUINO
`define ENABLE_GPIO

module DE10_LITE_Golden_Top(

	//////////// ADC CLOCK: 3.3-V LVTTL //////////
`ifdef ENABLE_ADC_CLOCK
	input 		          		ADC_CLK_10,
`endif
	//////////// CLOCK 1: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK1
	input 		          		MAX10_CLK1_50,
`endif
	//////////// CLOCK 2: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK2
	input 		          		MAX10_CLK2_50,
`endif

	//////////// SDRAM: 3.3-V LVTTL //////////
`ifdef ENABLE_SDRAM
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,
`endif

	//////////// SEG7: 3.3-V LVTTL //////////
`ifdef ENABLE_HEX0
	output		     [7:0]		HEX0,
`endif
`ifdef ENABLE_HEX1
	output		     [7:0]		HEX1,
`endif
`ifdef ENABLE_HEX2
	output		     [7:0]		HEX2,
`endif
`ifdef ENABLE_HEX3
	output		     [7:0]		HEX3,
`endif
`ifdef ENABLE_HEX4
	output		     [7:0]		HEX4,
`endif
`ifdef ENABLE_HEX5
	output		     [7:0]		HEX5,
`endif

	//////////// KEY: 3.3 V SCHMITT TRIGGER //////////
`ifdef ENABLE_KEY
	input 		     [1:0]		KEY,
`endif

	//////////// LED: 3.3-V LVTTL //////////
`ifdef ENABLE_LED
	output		     [9:0]		LEDR,
`endif

	//////////// SW: 3.3-V LVTTL //////////
`ifdef ENABLE_SW
	input 		     [9:0]		SW,
`endif

	//////////// VGA: 3.3-V LVTTL //////////
`ifdef ENABLE_VGA
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,
`endif

	//////////// Accelerometer: 3.3-V LVTTL //////////
`ifdef ENABLE_ACCELEROMETER
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,
`endif

	//////////// Arduino: 3.3-V LVTTL //////////
`ifdef ENABLE_ARDUINO
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,
`endif

	//////////// GPIO, GPIO connect to GPIO Default: 3.3-V LVTTL //////////
`ifdef ENABLE_GPIO
	inout 		    [35:0]		GPIO
`endif
);



//=======================================================
//  REG/WIRE declarations
//=======================================================




//=======================================================
//  Structural coding
//=======================================================

//=======================================================
//  Wires and Registers
//=======================================================
wire clk = MAX10_CLK1_50;    // 50 MHz clock
wire reset = ~KEY[0];        // Reset signal (active-low)
wire negReset = KEY[0]; 

// UART signals
wire [7:0] rx_byte;          // Data received
wire rx_ready;               // Data valid signal
reg [7:0] tx_byte; //reg           // Data to transmit
reg tx_start;      //reg          // Transmit signal
wire tx_idle;                // Ready signal
wire rx_stream = GPIO[2];    // UART RX
wire tx_stream;              // UART TX
assign GPIO[1] = tx_stream;  // Connect TX to Arduino

// LED control signal
reg rx_ready_latched;        // Latches the valid signal for persistent LED control

wire [31:0] bit_data;
wire data_ready;

//reg [31:0] r_bit_data;
//reg r_data_ready;

reg [31:0] instruction;
reg valid_instruction;
reg done;

wire il1_if1_write_enable;
wire [2:0] il1_if1_load_address;
wire [31:0] il1_if1_load_instruction;
wire id1_if1_flush;

wire [31:0] if1_id1_instruction;
wire if1_id1_data_ready;
wire [31:0] id1_al1_operand1;
wire [31:0] id1_al1_operand2;
wire [4:0] id1_al1_aluop;
wire al1_id1_flush;
wire [4:0] id1_rf1_addr1;
wire [4:0] id1_rf1_addr2;
wire id1_al1_dec_ins_ready;
wire [31:0] rf1_id1_reg_read_data1;
wire [31:0] rf1_id1_reg_read_data2;
wire id1_al1_mem_read;
wire id1_al1_mem_write;
wire [4:0] id1_al1_rd;
wire [31:0] al1_dm1_result;
wire [4:0] al1_dm1_rd;
wire al1_dm1_alu_ready;

wire al1_dm1_mem_read;
wire al1_dm1_mem_write;
wire rf1_dm1_flush;

wire dm1_rf1_data_ready;
wire [4:0] dm1_rf1_rd;
wire [31:0] dm1_rf1_write_data;
wire dm1_al1_flush;
//=======================================================
//  UART Module Instantiation
//=======================================================
serial_comm #(
    .SYS_CLK(50_000_000),   // 50 MHz clock
    .BAUD_RATE(9600)        // Baud rate
) serial_comm_inst (
    .clk(clk),
    .rst(reset),
    .rx_stream(rx_stream),
    .rx_byte(rx_byte),
    .rx_ready(rx_ready),
    .tx_stream(tx_stream),
    .tx_byte(tx_byte),
    .tx_start(tx_start),
    .tx_idle(tx_idle)
);


ascii_to_bits_converter test(
.clk(clk),
.rst(reset),
.rx_byte(rx_byte),
.rx_ready(rx_ready),
.bit_data(bit_data),
.data_ready(data_ready)
);


instructionLoad il(
	.clk(clk),
	.rst(negReset),
	.i_data_received(data_ready),
	.i_instruction(bit_data),
	.o_write_enable(il1_if1_write_enable),
	.o_address(il1_if1_load_address),
	.o_instruction(il1_if1_load_instruction),
	.o_debug_flag()
);

instructionFetch if1(
    .clk(clk),
    .rst(negReset),
    .i_write_enable(il1_if1_write_enable),
    .i_load_address(il1_if1_load_address),
    .i_load_instruction(il1_if1_load_instruction),
    .i_flush(SW[0]),
    .o_instruction(if1_id1_instruction),
    .o_data_ready(if1_id1_data_ready),
	.o_debug_flag()
);

instructionDecoder id1(
    .clk(clk),
    .rst(negReset),
    .i_instruction(if1_id1_instruction), // 32-bit i_instruction input
    .i_if_ready(if1_id1_data_ready),
    .i_flush(al1_id1_flush),
    .o_flush(id1_if1_flush),
    .o_operand1(id1_al1_operand1),
    .o_operand2(id1_al1_operand2),
    .o_ALUop(id1_al1_aluop),
    .o_addr1(id1_rf1_addr1),
    .o_addr2(id1_rf1_addr2),
    .o_dec_ins_ready(id1_al1_dec_ins_ready),
    .i_reg_read_data1(rf1_id1_reg_read_data1),
    .i_reg_read_data2(rf1_id1_reg_read_data2),
    .o_mem_read(id1_al1_mem_read),
    .o_mem_write(id1_al1_mem_write),
    .o_rd(id1_al1_rd),
	.o_debug_flag()
);


controlALU al1 (
    .clk(clk),
    .rst(negReset),
    .i_operand1(id1_al1_operand1),      // First operand
    .i_operand2(id1_al1_operand2),      // Second operand
    .i_ALUOp(id1_al1_aluop),          // Control signal to select the operation
    .i_flush(dm1_al1_flush),
    .o_result(al1_dm1_result),   // Result of the operation
    .zero (),            // Zero flag for branching
    .i_dec_ins_ready(id1_al1_dec_ins_ready),
    .o_flush(al1_id1_flush),
    .i_mem_read(id1_al1_mem_read),
    .i_mem_write(id1_al1_mem_write),
    .i_rd(id1_al1_rd),
    .o_mem_read(al1_dm1_mem_read),
    .o_mem_write(al1_dm1_mem_write),
    .o_rd(al1_dm1_rd),
    .o_alu_ready(al1_dm1_alu_ready),
	.o_debug_flag()
);


dataMemory dm1(
    .clk(clk),
    .rst(negReset),
    .i_result(al1_dm1_result),
    .i_mem_read(al1_dm1_mem_read),
    .i_mem_write(al1_dm1_mem_write),
    .i_rd(al1_dm1_rd),
    .i_alu_ready(al1_dm1_alu_ready),
    .o_flush(dm1_al1_flush),
    .o_write_data(dm1_rf1_write_data), // to write to reg file
    .o_rd(dm1_rf1_rd),
    .i_flush(rf1_dm1_flush),
    .o_data_ready(dm1_rf1_data_ready),
	.o_debug_flag()
);

	// Register file signals
    wire [31:0] reg_values [0:31];


registerFile rf1 (    
    .clk(clk),
    .rst(negReset),
    .i_rd(dm1_rf1_rd),
    .i_reg_read_addr1(id1_rf1_addr1),
    .i_reg_read_addr2(id1_rf1_addr2),
    .o_reg_read_data1(rf1_id1_reg_read_data1),
    .o_reg_read_data2(rf1_id1_reg_read_data2),
    .i_write_data(dm1_rf1_write_data),
    .o_flush(rf1_dm1_flush),
    .i_data_ready(dm1_rf1_data_ready),
	//.o_debug_flag({LEDR[4],LEDR[3],LEDR[2],LEDR[1],LEDR[0]}),
	.o_reg_array0(reg_values[0]),
	  .o_reg_array1(reg_values[1]),
	  .o_reg_array2(reg_values[2]),
	  .o_reg_array3(reg_values[3]),
	  .o_reg_array4(reg_values[4]),
	  .o_reg_array5(reg_values[5]),
	  .o_reg_array6(reg_values[6]),
	  .o_reg_array7(reg_values[7]),
	  .o_reg_array8(reg_values[8]),
	  .o_reg_array9(reg_values[9]),
	  .o_reg_array10(reg_values[10]),
	  .o_reg_array11(reg_values[11]),
	  .o_reg_array12(reg_values[12]),
	  .o_reg_array13(reg_values[13]),
	  .o_reg_array14(reg_values[14]),
	  .o_reg_array15(reg_values[15]),
	  .o_reg_array16(reg_values[16]),
	  .o_reg_array17(reg_values[17]),
	  .o_reg_array18(reg_values[18]),
	  .o_reg_array19(reg_values[19]),
	  .o_reg_array20(reg_values[20]),
	  .o_reg_array21(reg_values[21]),
	  .o_reg_array22(reg_values[22]),
	  .o_reg_array23(reg_values[23]),
	  .o_reg_array24(reg_values[24]),
	  .o_reg_array25(reg_values[25]),
	  .o_reg_array26(reg_values[26]),
	  .o_reg_array27(reg_values[27]),
	  .o_reg_array28(reg_values[28]),
	  .o_reg_array29(reg_values[29]),
	  .o_reg_array30(reg_values[30]),
	  .o_reg_array31(reg_values[31])
);

 // Clock devider (PLL) at 25MHz
 wire pixel_clk;
 pll pll (
	  .inclk0(MAX10_CLK1_50),
	  .c0(pixel_clk)
 );

// Display interface signals
 wire [7:0] text_data;
 wire [11:0] text_addr;
 wire text_we;

 // text writer instance
 text_writer #(
	  .COLS(80),
	  .ROWS(32)
 ) writer (
	  .clk(pixel_clk),
	  .reset_n(negReset),
	  .reg0(reg_values[0]),
	  .reg1(reg_values[1]),
	  .reg2(reg_values[2]),
	  .reg3(reg_values[3]),
	  .reg4(reg_values[4]),
	  .reg5(reg_values[5]),
	  .reg6(reg_values[6]),
	  .reg7(reg_values[7]),
	  .reg8(reg_values[8]),
	  .reg9(reg_values[9]),
	  .reg10(reg_values[10]),
	  .reg11(reg_values[11]),
	  .reg12(reg_values[12]),
	  .reg13(reg_values[13]),
	  .reg14(reg_values[14]),
	  .reg15(reg_values[15]),
	  .reg16(reg_values[16]),
	  .reg17(reg_values[17]),
	  .reg18(reg_values[18]),
	  .reg19(reg_values[19]),
	  .reg20(reg_values[20]),
	  .reg21(reg_values[21]),
	  .reg22(reg_values[22]),
	  .reg23(reg_values[23]),
	  .reg24(reg_values[24]),
	  .reg25(reg_values[25]),
	  .reg26(reg_values[26]),
	  .reg27(reg_values[27]),
	  .reg28(reg_values[28]),
	  .reg29(reg_values[29]),
	  .reg30(reg_values[30]),
	  .reg31(reg_values[31]),
	  .text_data(text_data),
	  .text_addr(text_addr),
	  .text_we(text_we)
 );

 // main display module
 vga_display display (
	  .clk(pixel_clk),
	  .reset_n(negReset),
	  .text_data(text_data),
	  .text_addr(text_addr),
	  .text_we(text_we),
	  .vga_hsync(VGA_HS),
	  .vga_vsync(VGA_VS),
	  .vga_r(VGA_R),
	  .vga_g(VGA_G),
	  .vga_b(VGA_B)
 );




// =======================================================
//  UART Communication and LED Control Logic
// =======================================================


// always @(posedge clk or posedge reset) begin
// 	if (reset) begin
// 		r_bit_ready <= 0;
// 		r_bit_data <= 0;
// 	end
// end

always @(posedge clk or posedge reset) begin
    if (reset) begin
        tx_byte <= 8'd0;
        tx_start <= 1'b0;
        //LEDR <= 10'b0;
        rx_ready_latched <= 1'b0;
    end else begin
        // Transmit received data back
        if (tx_idle && rx_ready) begin
            tx_byte <= rx_byte;  // Echo received data
            tx_start <= 1'b1;
        end else begin
            tx_start <= 1'b0;
        end
			
			/*
        // Latch valid signal for LED control
        if (rx_ready && rx_byte == 8'd49) begin
            rx_ready_latched <= 1'b1;  // Turn on LEDs for '1'
        end else if (rx_ready && rx_byte != 8'd49) begin
            rx_ready_latched <= 1'b0;  // Turn off LEDs for other values
        end

        // Control LEDs based on latched signal
        LEDR <= rx_ready_latched ? 10'b1111111111 : 10'b0;
		  */
		  
		  /*
		  if (data_ready && bit_data == 32'b00000000000000000000000000000001) begin
			LEDR <= 10'b1111111111;
		  end
		  else if (data_ready && bit_data == 32'b0) begin
			LEDR <= 10'b0;
		  end
		  */
    end
end

//assign r_bit_data = bit_data;
//assign r_data_ready = data_ready;


endmodule
